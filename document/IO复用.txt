include/cyx_util.h中：str_cli()
存在问题：
	1、如何高效正确处理多个文件描述？
	2、如何解决客户端由于发送完数据而关闭sockfd，但服务器发送的数据还未接受完的情况？
	3、混合使用stdio和select（使用select时读写操作如果存在缓冲区），对系统会造成怎样的影响？

解决方式：
1、IO复用的方式：
	检查--（阻塞）-->就绪发起--（阻塞）-->完成
	多路复用是指使用一个线程来检查多个文件描述符的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行，这样可以达到高效利用系统资源的效果。

该函数使用了IO复用，可以高效的处理来自不同文件描述符的反馈信息，此函数处理了来自sockfd和fp（标准输入流，或许是被重定向的）两个描述符，而不至于在sockfd由于服务器因为某些原因关闭或不可用而关闭时，客户端却阻塞在fp等待数据输入。

2、客户端读取从标准输入流（可能被重定向）读取完数据后，通过shutdown函数关闭sockfd读半部，同时将标准输入流从set中移除，当客户端接受完服务器发送的数据后在完全关闭sockfd。

3、如果混合使用stdio和select，往往或非常容易犯错误，例如该函数中所使用的fgets()从标准输入读取一行，假设这个时候标准输入被重定向为文件，且文件中存在多行，那么在调用fgets()时将会是所有的行读入到stdio缓冲区中但是只返回一行，于是writen()将获取到的这一行发送给服务器，随后select再次被调用以等待新的工作，而不管stdio缓冲区中是否还有数据，究其原因，select只是从read系统调用的角度指出是否有可读数据，而不是从fgets的角度。

解决了上述三个问题的函数是io_str_cli(),也位于include/cyx_util.h中。